# PoliTerm Orchestrator – Minimal Working Architecture (TUI-first, tmux-driven)

> **Purpose**: Build a **working engine** that orchestrates two AI CLI TUIs (Planner = `cli-1`, Executer = `cli-2`) in a **fully interactive TTY** without losing context.
> **Key idea**: Run both TUIs inside persistent **PTYs** (via `tmux` panes). A lightweight **orchestrator** injects input (like keystrokes) and reads output to automate the **Planner ⇄ Executer** dialogue loop.
> **Why**: TUIs maintain project-scoped sessions (`cwd`-based), preserve context across time, and support `--continue`/`resume` flows—unlike one-shot command invocations.

---

## 0. High-Level Goals

* ✅ Drive **two TUIs** in separate `tmux` panes: `Planner` (e.g., `claude`) and `Executer` (e.g., `codex`), each started in its own **workspace directory** so context is preserved.
* ✅ Establish a **machine-parsable contract** for inter-TUI messages using **tagged blocks** embedded in normal model output.
* ✅ Provide a **single orchestrator** process that:

  * Sends prompts to either TUI using **`tmux send-keys`** (true keystroke injection).
  * Watches pane output using **`tmux capture-pane`**, detects **tagged blocks**, and triggers the other TUI.
  * Implements **stand-by → auto-trigger** logic (automatic forward/back when blocks appear).
* ✅ Ship a **minimal, runnable prototype** that proves the loop works before we add options (ZMQ/gRPC buses, multi-host, UI, etc.).

---

## 1. Architecture (MVP)

```
+---------------------+       +---------------------+
|  tmux session 'main'|       |  Orchestrator (Py)  |
|  socket: -L poli    |       |---------------------|
|---------------------|       | - send_keys(pane..) |
| [pane 0] PLANNER    |<----->| - capture_tail(..)  |
|   cmd: claude       |  I/O  | - parse_blocks(..)  |
|   cwd: /ProjA       |       | - loop: Planner→Exec|
|---------------------|       |         →Planner... |
| [pane 1] EXECUTER   |       +---------------------+
|   cmd: codex        |
|   cwd: /ProjA       |
+---------------------+
```

**Key decisions**

* **PTY/TUI**: We never “call the CLI” in one-shot mode. Instead, we keep **long-lived TUIs** running inside PTYs so workspace session state is retained.
* **tmux control**: Orchestrator controls panes via `tmux -L poli` socket using:

  * `send-keys` (inject input, including `Enter`)
  * `capture-pane -pJS -N` (tail of pane buffer)
* **Message contract**: TUIs output **tagged blocks** we can reliably parse and route.

---

## 2. Message Contract (Tagged Blocks)

We enforce a **minimal protocol** that works in plain text, without altering model behavior:

```text
[[POLI:MSG {"to":"EXECUTER","type":"plan","id":"<uuid-or-string>"}]]
<PLAN>
...natural language plan, step by step...
</PLAN>
[[/POLI:MSG]]
```

Executer replies:

```text
[[POLI:MSG {"to":"PLANNER","type":"result","id":"<same-or-new-id>"}]]
<RESULT>
...concise result / notes / blockers...
</RESULT>
[[/POLI:MSG]]
```

* JSON in the opening tag carries **routing metadata** (`to`, `type`, `id`).
* The body can be any text; we wrap recommended sections (`<PLAN>`, `<RESULT>`).
* Orchestrator **parses these blocks** and triggers the next TUI automatically.

**Primer prompts** (seed once per TUI at startup):

**PLANNER PRIMER**

```
You are PLANNER. When you finish thinking, emit a single tagged block:

[[POLI:MSG {"to":"EXECUTER","type":"plan","id":"$ID"}]]
<PLAN>
...natural language plan, step by step...
</PLAN>
[[/POLI:MSG]]

Do nothing else after emitting the block. Wait silently for the next user input.
```

**EXECUTER PRIMER**

```
You are EXECUTER. When you receive a plan, act on it. After you finish:
1) (Optional) Emit STATUS blocks for progress.
2) Emit a final tagged block back to PLANNER:

[[POLI:MSG {"to":"PLANNER","type":"result","id":"$ID"}]]
<RESULT>
...concise result / notes / blockers...
</RESULT>
[[/POLI:MSG]]

After emitting the final block, wait silently for the next input.
```

> The `$ID` can be generated by the orchestrator for each task and included in the **user’s first message**, instructing both TUIs to **reuse** that id in all blocks.

---

## 3. Repo Layout (MVP)

```
politerm/
├─ README.md                # this file
├─ scripts/
│  ├─ bootstrap_tmux.sh     # creates tmux session/panes and injects primers
│  └─ kill_tmux.sh          # cleanup session/socket
├─ proto/
│  └─ poli_orchestrator.py  # minimal orchestrator engine (works today)
├─ config/
│  └─ poli.env              # CLI commands, workspaces, timeouts
└─ tests/
   └─ smoke_loop.sh         # single E2E smoke run
```

---

## 4. Prerequisites

* macOS or Linux
* `tmux` ≥ 3.x
* Python 3.10+ (stdlib only for MVP)
* Two TUIs installed and available in `$PATH`, e.g.:

  * `claude` for PLANNER
  * `codex` for EXECUTER

> Replace with your actual TUI commands if different (same orchestration applies).

---

## 5. Bootstrapping tmux Session

**`scripts/bootstrap_tmux.sh`**

```bash
#!/usr/bin/env bash
set -euo pipefail

SOCKET="poli"
SESSION="main"

PLANNER_CWD="${PLANNER_CWD:-$HOME/Workspace/ProjA}"
EXECUTER_CWD="${EXECUTER_CWD:-$HOME/Workspace/ProjA}"
PLANNER_CMD="${PLANNER_CMD:-claude}"
EXECUTER_CMD="${EXECUTER_CMD:-codex}"

# New session with custom socket (-L)
tmux -L "$SOCKET" -f /dev/null new -d -s "$SESSION" -c "$PLANNER_CWD"

# Start PLANNER in pane 0
tmux -L "$SOCKET" send-keys -t "$SESSION".0 "$PLANNER_CMD" C-m

# Split and start EXECUTER in pane 1
tmux -L "$SOCKET" split-window -h -t "$SESSION" -c "$EXECUTER_CWD" "$EXECUTER_CMD"

sleep 1

# Inject PRIMERS (paste as single enter-terminated lines; you can also read from files)
tmux -L "$SOCKET" send-keys -t "$SESSION".0 "PASTE_PLANNER_PRIMER" C-m
tmux -L "$SOCKET" send-keys -t "$SESSION".1 "PASTE_EXECUTER_PRIMER" C-m

echo "tmux ready: -L $SOCKET, session $SESSION (planner pane 0, executer pane 1)"
```

**`scripts/kill_tmux.sh`**

```bash
#!/usr/bin/env bash
set -euo pipefail
tmux -L poli kill-session -t main || true
```

---

## 6. Orchestrator (Runnable Prototype)

**`proto/poli_orchestrator.py`**

```python
import json, re, subprocess, time, uuid

SOCKET = "poli"
SESSION = "main"
PLANNER_PANE = f"{SESSION}.0"
EXECUTER_PANE = f"{SESSION}.1"

TMUX = ["tmux", "-L", SOCKET]

def sh(args: list[str]) -> str:
    return subprocess.check_output(args, text=True)

def send_keys(target: str, text: str, with_enter: bool = True) -> None:
    # Paste line-by-line; preserves newlines and keeps TUI happy
    for line in text.split("\n"):
        if line:
            sh(TMUX + ["send-keys", "-t", target, line])
        if with_enter:
            sh(TMUX + ["send-keys", "-t", target, "C-m"])

def capture_tail(target: str, lines: int = 400) -> str:
    # -p = print pane, -J = join wrapped lines, -S start from (negative = from end)
    return sh(TMUX + ["capture-pane", "-t", target, "-pJS", f"-{lines}"])

BLOCK_RE = re.compile(
    r"\[\[POLI:MSG\s+(\{.*?\})\]\]\s*(.*?)\s*\[\[/POLI:MSG\]\]",
    re.DOTALL,
)

def find_blocks(buf: str) -> list[tuple[dict, str]]:
    blocks = []
    for m in BLOCK_RE.finditer(buf):
        meta = json.loads(m.group(1))
        body = m.group(2)
        blocks.append((meta, body))
    return blocks

def wait_for_new_block(target: str, seen_ids: set[str], timeout: float = 120.0):
    t0 = time.time()
    while time.time() - t0 < timeout:
        buf = capture_tail(target)
        for meta, body in find_blocks(buf):
            bid = str(meta.get("id"))
            if bid and bid not in seen_ids:
                return meta, body
        time.sleep(0.4)
    return None, None

def route_once(user_prompt: str) -> bool:
    task_id = str(uuid.uuid4())

    # 1) User → PLANNER
    first = f"""TASK_ID={task_id}

User request:
{user_prompt}

Please produce exactly one tagged block addressed to EXECUTER with id={task_id}.
"""
    send_keys(PLANNER_PANE, first)

    # 2) Wait Planner → plan block
    seen = set()
    meta, body = wait_for_new_block(PLANNER_PANE, seen, timeout=180)
    if not meta:
        return False
    seen.add(str(meta["id"]))

    # 3) Forward to EXECUTER
    forward = f"""You received a PLANNER plan block:

[[POLI:MSG {json.dumps(meta)}]]
{body}
[[/POLI:MSG]]

Execute the plan. When done, emit a RESULT block back to PLANNER with id={task_id}.
"""
    send_keys(EXECUTER_PANE, forward)

    # 4) Wait Executer → result block
    meta2, body2 = wait_for_new_block(EXECUTER_PANE, set(), timeout=900)
    if not meta2:
        return False

    # 5) Forward back to PLANNER asking for user-facing summary
    back = f"""EXECUTER replied:

[[POLI:MSG {json.dumps(meta2)}]]
{body2}
[[/POLI:MSG]]

Now produce a concise final report for the user (no new POLI blocks).
"""
    send_keys(PLANNER_PANE, back)

    return True

if __name__ == "__main__":
    ok = route_once("Analyze README in /ProjA, then prepare and run a matching script in /ProjA.")
    print("DONE:", ok)
```

**Run (MVP):**

```bash
# 1) Start panes + primers
bash scripts/bootstrap_tmux.sh

# 2) Run orchestrator once
python3 proto/poli_orchestrator.py

# 3) (Optional) Attach to observe panes
tmux -L poli attach -t main
```

**Expected behavior**

* Planner emits a `plan` block → orchestrator detects it → pushes to Executer.
* Executer executes → emits `result` block → orchestrator forwards back → Planner summarizes.
* All without leaving the TUIs or losing context.

---

## 7. Configuration (edit-friendly)

**`config/poli.env`** (example variables you can source before bootstrapping):

```bash
export PLANNER_CMD="claude"
export PLANNER_CWD="$HOME/Workspace/ProjA"

export EXECUTER_CMD="codex"
export EXECUTER_CWD="$HOME/Workspace/ProjA"

export POLI_TMUX_SOCKET="poli"
export POLI_TMUX_SESSION="main"

export POLI_PLAN_TIMEOUT=180
export POLI_EXEC_TIMEOUT=900
```

Adjust `scripts/bootstrap_tmux.sh` and `proto/poli_orchestrator.py` to read envs if desired.

---

## 8. Test Plan (MVP)

* **Smoke**: One end-to-end route with trivial task (see `proto/poli_orchestrator.py`).
* **Planner stall**: Simulate no POLI block → expect timeout and clear log.
* **Executer stall**: Simulate long run → expect timeout handling and retry hook.
* **Malformed block**: Planner prints partial tags → parser ignores until a well-formed block appears.
* **Resize** (manual): Ensure TUIs render OK when you resize `tmux` panes.

Optional script: `tests/smoke_loop.sh` calling bootstrap → orchestrator → assert “DONE: True”.

---

## 9. Reliability & Hardening

* **Pane filtering**: Tail only last N lines (`capture-pane -pJS -N`) to reduce noise.
* **Last complete block**: If multiple blocks exist, prefer the **last well-formed** block.
* **Nudges**: If timeout nears, send a gentle “If finished, emit the tagged block now.” hint via `send-keys`.
* **State table**: Track `task_id → expected_from → expected_type`. Enables multiple concurrent tasks (extend later).
* **Interrupts**: Provide a hotkey or orchestrator command to **abort** or **retry** a step (send Ctrl-C, etc.).
* **Logging**: Write parsed blocks and routing decisions to a file for audit.

---

## 10. Security Notes

* **Local only** for MVP. The orchestrator controls your TTY—treat it as trusted local automation.
* Avoid exposing the tmux socket externally. If you must, use **SSH** and system ACLs.
* Later, if we add remote control: use **mTLS / SSH tunnels / UDS permissions** (no raw TCP).

---

## 11. Extensions (Phase-2+)

* **Message bus (local)**: Plug a **ZeroMQ (ipc)** ROUTER/DEALER between orchestrator and adaptors to support multiple hosts/agents cleanly.
* **Typed API**: Replace internal calls with **gRPC over UDS** for typed commands (`StartTui, SendKeys, Capture, Resize, Resume`).
* **UI/Monitor**: Add a thin **xterm.js** view that mirrors panes (optional; not needed for core engine).
* **Multi-task queue**: Accept many tasks, run sequentially or schedule across agents.
* **Auto-resume**: On crash/restart, re-attach to existing `tmux` session and continue.

---

## 12. Acceptance Criteria (for this MVP)

* [ ] `bootstrap_tmux.sh` creates a session with two TUIs running in correct `cwd`s.
* [ ] PRIMERs successfully injected; TUIs acknowledge input.
* [ ] `poli_orchestrator.py` routes **Planner → Executer → Planner** at least once using **tagged blocks**.
* [ ] No TUI context loss (you can `tmux attach` and see ongoing sessions).
* [ ] Timeouts are surfaced with clear messages (not silent hangs).

---

## 13. Notes for the AI Code Assistant

* Keep the prototype **small and deterministic**. Don’t pull extra libs for MVP.
* Respect **line discipline** in `send-keys` (send each line + `C-m`).
* Ensure **regex** is non-greedy and robust to model verbosity.
* Don’t change the TUIs’ normal behavior; the **tagged block contract** is the only constraint we add.
* All paths/commands should be configurable via env vars.

---

**Bottom line:** This document defines a **working, testable engine**: `tmux` panes host **real TUIs**, the **orchestrator** automates the Planner⇄Executer loop via **tagged blocks**, and we validate end-to-end without touching WebSockets or one-shot CLI calls. Once this is green, we can build the optional buses (ZMQ/gRPC) and UI on top.
